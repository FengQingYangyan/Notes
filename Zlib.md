

## Zlib

### 压缩文件格式

| No. of byte |                 |                         Description                          | bits |        |                         Description                          |
| :---------: | :-------------: | :----------------------------------------------------------: | :--: | :----: | :----------------------------------------------------------: |
|      1      |       CMF       |         Compression Method and Flags：压缩方法和标志         | 0-3  |   CM   |                 Compression Method：压缩方法                 |
|     4-7     |      CINFO      | Compression info：压缩信息，对于CM=8，CINFO是LZ77窗口的大小以2为底的对数加上8（CINFO=7表示窗口大小为32k）。在RFC1950规范中，不允许将CINFO的值在7以上，并且对于CM!=8的情况没有定义。 |      |        |                                                              |
|      1      |       FLG       |                            FLaGs                             | 0-4  | FCHECK | 检查CMF和FLG位：FCHECK 在当 CMF 和 FLG 被视为按 MSB 顺序存储的一个 16 位无符号整数（CMF*256 + FLG）时，必须是 31 的倍数。 |
|      5      |      FDICT      | 预置字典：最初送到压缩程序而不产生任何压缩输出的一系列字节； |      |        |                                                              |
|     6-7     |     FLEVEL      | 压缩级别：不同的值对应与不同的压缩级别，当CM=8时，将压缩级别设置为，但是在解压程序中，不需要该部分的信息：0-压缩程序使用最快的算法；1-压缩程序使用较快的算法；2-压缩程序使用较少的算法；3-压缩程序使用最大的压缩，最慢的算法。 |      |        |                                                              |
|      4      |      DICT       |               字典标识符：预置字典的32位检验和               |  32  |        | 如果FDICT位被设置，则该标识符立即出现在FLG字节之后，如果未设置，则该字节不出现； |
|             | compressed data |              在Zlib中支持的仅有DERLATE压缩方法               |      |        | 在该压缩方法中，压缩数据格式 由 DEFLATE压缩数据格式规范 定义； |
|      4      |     ADLER32     |                        Adler-32检验和                        |  32  |        |    包含了一个按照Adler-32算法计算出的未压缩数据的校验值。    |

以上部分整理自RFC1950，文档位于https://github.com/madler/zlib/tree/master/doc，对RFC1950的翻译可以参考http://www.360doc.com/content/11/0111/18/2036337_85806230.shtml



### DEFLATE压缩数据格式规范

#### 压缩数据概述

压缩数据是由一系列的块组成，与输入的块相对应。块的大小是任意的，但是未压缩块的大小要在65536字节之内。

每一块的压缩使用了LZ77算法和Huffman编码树。每块的Huffman树都和它的前一块及后一块无关，LZ77算法会参考前一块的最多32K的内容。

每块由两部分组成：其中一部分为一对Huffman树，描述了压缩内容的表示方法（其中的Huffman树也是经过Huffman编码压缩过的）；另一部分为压缩数据部分。

压缩数据由两种类型的一系列元素组成：文字字节（字符串的一部分，但不是复制的前32K的内容）；指向复制内容的“指针”，指针表示为一个<长度，距离>对，其中距离限制在258字节，长度限制在32K，但是没有限制块的大小。压缩数据中的每种类型的值都是经过Huffman树编码的，一棵树编码文字和长度，一棵树编码距离。

由以上部分可以得知一个压缩块的组成为：

|     压缩块     |          |          |        |
| :------------: | -------- | -------- | ------ |
|   Huffman树    | 压缩数据 |          |        |
| 编码文字和长度 | 编码距离 | 文字字节 | “指针” |

#### 块结构的详细资料

| No. of bits | Name   | Description                                                  |                         |
| ----------- | ------ | ------------------------------------------------------------ | ----------------------- |
| 1           | BFINAL | 当该块为最后一块时，才设置该位                               |                         |
| 2           | BTYPE  | 指定块数据是如何压缩的：00 —— no compression 非压缩；01 —— comrpession with fixed Huffman codes 静态Huffman编码；10 —— compression with dynamic Huffman codex 动态Huffman编码；11 ——reserver（error）保留（错误）； |                         |
| 5           | 忽略   | 如果为非压缩的块，将会忽略直到下一个字符边界的所有位         | 当BTYPE为00时的数据格式 |
| 16          | LEN    | 块中的字节数                                                 |                         |
| 16          | NLEN   | LEN的补码                                                    |                         |
| LEN * 8     | DATA   | LEN字节的数据                                                |                         |
|             |        |                                                              |                         |